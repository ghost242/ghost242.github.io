---
layout: post
title: 함수에 대해서
subtitle: Basic of function in Programming
parent: Haskell
has_toc: true
comments: true
categories: ["Programming", "Haskell"]
tag: ["Haskell", "Functional programming"]
---

## Abstract

Functional language 중 하나인 Haskell은 코드의 안정성을 위해 제안되었던 몇가지 특징이 강하게 남아있는 언어이다. 그 중심에 바로 함수인데, Haskell은 현대에 주류로 자리잡은 언어의 구조와 상당히 다른 형태를 갖고있다. 이 문서에서는 언어에 대해 공부하면서 참고했던 자료 일부와 함께 함수 구조 자체를 기본으로 기록한다.

## Basis

가장 많이 참고했던 수학 이론은 바로 집합이다. 현대 수학에서 집합을 파고 들어가면 한도 끝도 없이 파고들게 되고 얼마 안가서 대체 뭘 하려고했는지 잊어버리게 되는데, 프로그래밍 언어에서는 그 정도로 고도화된 이론을 바탕으로 하지 않는다. 집합에 대해 알아야 할 것들은 아래와 같다.

### Useful knowledge in the Set theory

위키피디아에서는 집합(Set)을 이렇게 말하고 있다.

`어떤 명확한 조건을 만족시키는 서로 다른 대상들의 모임이다.`([집합 in Wikipedia](https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9))

수학이라는 분야 자체에 얽매이면 이 `대상`을 숫자 이외에 더 넓은 개념으로 확장시키지 못하기도 하는데, 집합에서 대상은 반드시 숫자일 필요가 없다. 집합에서 다루는 `대상`은 숫자나 수식, 문자, 사물, 개념 등등 모든 것이다. 물론 이 방향으로 사고를 확장하다보면 집합이 `대상`인 집합을 생각하게되면서 `러셀의 역설`에 맞닥들일 수 있기 때문에 더 엄밀한 정의를 필요로 한다면 현대 수학의 기반이 되고있는 [ZFC 공리계](https://ko.wikipedia.org/wiki/%EC%B2%B4%EB%A5%B4%EB%A9%9C%EB%A1%9C-%ED%94%84%EB%A0%9D%EC%BC%88_%EC%A7%91%ED%95%A9%EB%A1%A0)을 살짝 찾아볼 수는 있다.

우리가 이해해야 할 점은 바로 두 집합간의 대응관계이다. 한 집합의 대상과 다른 집합의 대상끼리 연관을 지을 수 있는데 이 관계가 여러 대상에 적용된다면 두 집합은 대응관계라고 할 수 있다. 이 관계는 크게 네가지 종류가 있는데, 1:1 대응, 1:n 대응, n:1 대응, m:n 대응이다.

이제 바로 여기에서부터 `함수`가 나온다. `함수`는 대응 관계 중에서도 특수한 것으로, 두 집합의 1:1 대응, n:1 대응 만을 표현할 수 있다. 1:n이나 m:n으로 표현되는 것이 있다면 그것은 `함수`라고 부르지 않는다. 수학적 개념이니 수학적인 느낌으로 표현해보면 이렇게 볼수있다.

set A 와 set B 가 있으면 함수 f는 f: A -> B 이다. a <- A, b <- B 라면, f(a) = b 라고 표현한다.

### About function

현대에 주류 언어에서는 거의 함수라는 용어로 통용되어가는것 같다. 하지만 원래 비슷한 개념들이 프로그래밍 언어에는 아주 많았는데, Function, Procedure, Subroutine, 그리고 OOP에서 사용되는 Method이다. 모두 비슷하지만 다른 용어이다.

프로그램 코드 덩어리를 하나의 작업으로 보면 항상 같은 과정으로 작업을 수행하기 때문에 Routine 이라고 부른다. 이 Routine을 분할하면 각각을 Subroutine이라고 부른다. Procedure는 프로그램 코드를 특정한 목적을 달성하기위한 Process라고 할 때 그 Process 묶음을 Procedure라고 부른다. Method란 어떤 사람, 동물, 기계, 각종 사물, 개념적인 뭔가가 하는 행위 자체를 의미한다. 이 개념은 Procedure와 Routine을 포함하고 있다. 그래서 Method는 항상 Class 안에서만 정의되고 Class로 생성된 Object에서 호출한다.

이 개념들을 두고 보면 Subroutine, Procedure, Method는 모두 호출되는 시점의 환경과 조건에 영향을 받는다. Function(함수)는 그런 점이 다른데, 다른 언어에서는 혼용해도 상관없지만 Haskell 등의 일부 Pure functional language에서는 반드시 구분해야 한다.

## Function in Haskell

위의 내용을 보고 Haskell의 함수를 보면 왜 이렇게 될 수밖에 없는지 이해할 수 있다. 간단하게 \(f(x) = x + 1\) 을 Haskell 문법으로 표현하면 이렇게 된다.

```haskell
f :: Num -> Num
f x = x + 1
```

여기에서 f가 이름, Num이 데이터 타입, x가 Argument 이다. Haskell에서는 함수 자체에 다양한 문법 기능을 지원한다. 여기서부터 Haskell에서 함수에 제공하는 문법의 핵심이 되는 문법들을 압축해서 기록해둔다.

### Pattern matching

이 기능은 수학에서 흔히 쓰이는 표현과 대응된다. 간단한 함수를 예로 들어서 보면 이런걸 들 수 있다.

$$ 
\begin{cases}
&y = x + 1 (x\ge0) \\
&y = 1 (x\lt0)
\end{cases}
$$

이 함수를 Haskell 문법으로 표현하면 이렇게 표현한다.

``` haskell
y :: Num -> Num
y x 
    | x >= 0 = x + 1
    | x < 0 = 1
```

여기서 `|`를 가드(Guard)라고 부른다. Haskell 에서는 Procedure language 패러다임에서 보이는 분기 구문이 없기 때문에 이러한 방법으로 조건에 따라 다른 연산을 할 수 있게 수식을 분리할 수 있다. 위에서 이야기했던 함수의 특징에는 순차실행의 개념이 없기 때문이다. 

### Recursive function

프로그래밍 코드를 해석하는 컴파일러나 인터프리터는 코드 안에 정의되어있는 함수 안에서 같은 함수를 또 쓸 수 있다. 이런 함수를 재귀적 함수 라고 부르는데, 수학에서 가장 쉽게 볼 수 있는 형태는 바로 집합을 표현하는 방법 중 하나인 점화식이 있다. 예를 들면 이런 것들이 있다.

$$
\begin{cases}
&a_1 = 1 \\
&a_n = a_{n-1} + 2 
\end{cases}
$$

이 함수는 그대로 Haskell로 표현하면 이렇게 된다.

``` haskell
a :: Int -> Int
a x
    | x > 1 = a(x-1) + 2
    | x == 1 = 1
```

이 코드를 약간 해석한다면 함수는 정수 값을 입력 받아서 정수 값을 반환하는 함수인데, 이 점화식으로 표현되는 집합의 x 번째 수를 구하는 함수가 된다. 이러한 재귀적 함수를 작성할 때는 반드시 재귀가 종료되는 지점을 알려주어야 한다.

여기에 약간 공학적인 관점에서 이유를 붙이자면, 컴파일러는 함수를 호출하는 시점을 메모리 스택에 기록해두는데, 호출 한 함수가 끝났을 때 다시 호출시점으로 돌아오게 하기위함이다. 그런데 메모리에는 항상 한계가 있어서 무한 재귀함수는 공학적으로 불가능하기 때문에 시스템은 늘 재귀 한계를 정의해둔다. 따라서 이 한계를 넘어서는 순간 Stack overflow, 혹은 Segmentation fault로 프로그램을 강제로 종료시켜버린다. 이런 조치가 없으면 프로그램 카운터가 이 프로그램이 할당받은 메모리 양을 무단으로 넘어가게되고 확률적으로 여러 다른 프로그램에 말도 안되는 영향을 줄 수 있기 때문에 OS가 메모리를 관리하려는 차원에서도 강제로 종료시키는 것이다. 

Haskell 에는 Lazy evaluation 등의 다양한 최적화 기법들을 이용해서 메모리가 무작정 낭비되는 문제를 피하기 떄문에 쉽게 오류를 볼 수는 없겠지만 무한히 긴 실행시간을 보게된다. 무슨말이냐면, 재귀 함수가 무한히 반복되지 않게 해야 한다는 것이다. 

## Conclusion

아주 간단하고 가볍게 함수에 대해 정리하고 이게 Haskell에서 어떻게 표현되는지 정리해봤다. 너무 짧게 정리하려고 했더니 논리적인 비약도 있고 건너뛴 점도 많고 왜곡도 있을 수 있지만 대충 아는대로 정리한 내용이라서 나중에 더 많이 알게되면 좀 더 내용을 보완해서 새로운 글로 만들어야 할 것 같다. 특히 함수에 대해서는 Haskell을 포함해서 Functional programming 자체를 이해하기 위해 집합론을 대충 훑었던 지식을 짜집기한 결과이기 때문에 실제로는 아닌 내용이 있을 수 있다. 

Haskell에서의 함수도 겨우 이 정도만 갖고 프로그램을 쓸 수는 없다. 하지만 기초적인 수준에서 프로그램을 작성하는데는 문제가 없을 것 같아 주관적인 기준에서 제일 중요하다 싶은 문법 구조를 두가지만 예제코드와 함께 요약했다. 나중에 다른 언어에서 Functional programming을 할 때 참고가 되길 바라면서..